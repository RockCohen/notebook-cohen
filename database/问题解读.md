# 1 磁盘操作粒度的影响.
**问题描述:**

- **除了磁盘访问本身的成本之外，磁盘操作的最小单元是块这一事实是构建有效的磁盘存储结构的主要限制和设计条件**

**问题分析:**

磁盘的物理特性决定了其读写操作的最小单位是"块"（block），通常为4KB、8KB等。即使只需要读取或写入一个字节的数据，磁盘也必须以块为单位进行操作。

这一事实对磁盘存储结构的设计产生了深远影响，主要体现在以下几个方面：

## 1.1 块的最小操作单元限制
- **空间利用率**：如果数据项远小于块大小，直接存储会造成空间浪费。例如，存储大量小文件时，每个文件至少占用一个块，导致磁盘碎片和空间浪费。
- **I/O效率**：批量读写块可以提升I/O效率，但也可能导致不必要的数据被加载到内存中。

## 1.2 设计磁盘存储结构的实际例子
### 例子1：文件系统的块分配
以Ext4文件系统为例，所有文件都以块为单位分配空间。即使一个文件只有1字节，也会占用一个完整的块（如4KB）。

这就是为什么存储大量小文件时，磁盘空间利用率会降低。

```
+-------------------+-------------------+-------------------+
|      Block 1      |      Block 2      |      Block 3      |
+-------------------+-------------------+-------------------+
| 文件A(1KB)        | 文件B(2KB)        | 文件C(1B)           |
| 剩余空间(3KB)      | 剩余空间(2KB)      | 剩余空间(4095B)     |
+-------------------+-------------------+-------------------+
```
**说明**：每个文件最小占用一个块，即使文件很小也会造成空间浪费。

### 例子2：数据库的页（Page）管理
- 便于批量读写，提高I/O效率。
- 支持高效的缓存和缓冲区管理。
- 便于实现B+树等索引结构，每个节点对应一个或多个页。

```
+-------------------+-------------------+-------------------+
|    Page 1 (8KB)   |    Page 2 (8KB)   |    Page 3 (8KB)   |
+-------------------+-------------------+-------------------+
| Block 1 | Block 2 | Block 3 | Block 4 | Block 5 | Block 6 |
+---------+---------+---------+---------+---------+---------+
```
**说明**：数据库通常以页为单位管理数据，每页由若干个磁盘块组成，便于批量I/O和缓存管理。

### 例子3：B+树索引结构
B+树广泛用于数据库和文件系统索引。其每个节点的大小通常设计为与磁盘块或页大小一致，这样每次磁盘I/O都能完整地读写一个节点，最大化I/O效率。

```
        [B+树根节点]
              |
    +---------+---------+
    |                   |
[节点1(=1块)]     [节点2(=1块)]
    |                   |
[叶子节点(=1块)]  [叶子节点(=1块)]
```
**说明**：B+树的每个节点大小设计为与磁盘块一致，保证每次I/O都能完整读写一个节点，提高效率。

## 1.3 设计启示
- 存储结构应尽量使数据的逻辑单元与物理块对齐，减少I/O次数。
- 对于大量小数据项，可以采用块内多项存储、压缩等方式提升空间利用率。
- 索引结构应考虑块大小，优化节点分布以减少磁盘访问次数。

综上，磁盘以块为最小操作单元不仅影响了存储空间的利用，还直接决定了存储结构的设计方式，是数据库和文件系统等高效运行的基础。

# 2 磁盘存储结构设计优化：减少磁盘访问的策略

**问题描述：**

- 磁盘存储结构的设计要充分考虑目标存储介质的特性，并且通常要为实现更少的磁盘访问进行优化。我们可以通过提高局部性、优化结构的内部表示以及减少页外指针的数量来实现这一点。

## 2.1 提高局部性

局部性分为**时间局部性**和**空间局部性**。通过将相关数据尽量存储在相邻的块或页中，可以减少磁盘寻道和I/O次数。

**图示：**

```
+---------+---------+---------+---------+
|  页1    |  页2    |  页3    |  页4    |
+---------+---------+---------+---------+
|数据A,B  |数据C,D  |数据E,F  |数据G,H  |
+---------+---------+---------+---------+
```

**说明**：将经常一起访问的数据（如A、B）存储在同一页或相邻页中，提升空间局部性，减少磁盘访问。

## 2.2 优化结构的内部表示

合理设计数据结构的内部布局，使其更好地适应磁盘块/页的大小。例如，B+树节点大小与页对齐，哈希桶分布均匀，减少溢出页。

**图示：**

```
        [B+树根节点(1页)]
               |
      +--------+--------+
      |                 |
[节点1(1页)]      [节点2(1页)]
      |                 |
[叶1(1页)]        [叶2(1页)]
```

**说明**：每个节点与页对齐，保证每次I/O都能完整读写一个节点，提升效率。

## 2.3 减少页外指针数量

页外指针（如溢出页、间接寻址）会导致一次逻辑访问需要多次磁盘I/O。通过优化分配策略、合并小数据项等方式，可以减少页外指针数量。

**图示：**

```
+---------+---------+---------+
|  页1    |  页2    |  页3    |
+---------+---------+---------+
|数据A,B  |数据C,D  |溢出页→ |
+---------+---------+---------+
```

**说明**：减少溢出页（页外指针），可降低访问链路长度，减少I/O次数。

## 2.4 设计总结
- 提高局部性：相关数据物理上靠近，减少I/O。
- 内部表示优化：结构与块/页对齐，提升批量I/O效率。
- 减少页外指针：优化分配和布局，降低访问链路长度。

通过上述策略，磁盘存储结构能够更高效地利用磁盘特性，显著减少磁盘访问次数，提升整体系统性能。

# 3 B树查找复杂度分析

B树作为数据库和文件系统常用的索引结构，其查找复杂度可以从两个角度分析：

## 3.1 块传输次数（磁盘I/O次数）

B树的每个节点通常设计为与磁盘块或页大小一致。假设每个节点最多有N个键（即阶为N+1），每个节点的子节点数为N+1。

- **每次查找从根节点出发，逐层向下，直到叶子节点。**
- 每往下走一层，节点个数增加N倍，搜索空间缩小为原来的1/N。
- 因此，树的高度h约为：

  $$
  h = \log_N M
  $$
  其中M为B树中总的数据项数。
- 查找一个键时，最多需要访问h个节点（即h次磁盘I/O），也就是最多传输 $\log_N M$ 个块。

**图示：**

```
        [根节点]
         /  |  \
      /    |    \
 [子节点1][子节点2][子节点3] ...
      |        ...        |
   [叶节点1] ...      [叶节点N]
```

每访问一层节点就需要一次块传输，直到叶子节点。

## 3.2 比较次数（CPU内二分查找）

- 在每个节点内部，查找具体的键通常采用二分查找。
- 每个节点有N个键，二分查找的复杂度为 $\log_2 N$。
- 整个查找过程中，最多需要比较 $h \times \log_2 N$ 次。
- 由于M远大于N，整体复杂度近似为 $\log_2 M$。

**图示：**

```
[节点内容: 10 | 20 | 30 | 40 | 50]
   ↑   ↑   ↑   ↑   ↑
二分查找定位目标键
```

## 3.3 总结

- **块传输次数**：约为 $\log_N M$，即树的高度。
- **比较次数**：约为 $\log_2 M$，即节点内二分查找的总次数。

B树通过增大节点（块）内的键数N，显著降低了树的高度，从而减少了磁盘I/O次数，是高效的外存索引结构。

# 4 B树布局与构造详解

为了简化B树的布局，我们假设每个节点都占据单个页。页由定长的头部、单元格指针块和单元格构成。单元格包含键和指向子节点或关联的数据记录的指针。B树使用简单的指针层级结构：页标识符用于在树文件中定位子节点，而单元格偏移量用于在页内定位单元格。

## 4.1 B树页面布局（自顶向下）

### 4.1.1 页面整体结构

```
+-------------------------+ ← 页面起始地址（8KB页面示例）
|     页面头部 (Header)    |  固定大小，如20字节
|   - 页面类型            |
|   - 键的数量            |
|   - 父页面ID            |
|   - 自由空间指针        |
+-------------------------+
|   单元格指针数组         |  可变大小，每个指针2-4字节
|   [offset1][offset2]    |  指向各单元格在页面内的位置
|   [...][offsetN]       |
+-------------------------+
|                        |
|     自由空间           |  动态分配给新单元格
|                        |
+-------------------------+
|       单元格N          |  ← 从页面底部向上增长
|       ...             |
|       单元格2          |
|       单元格1          |  ← 最早插入的单元格
+-------------------------+ ← 页面结束地址
```

### 4.1.2 页面头部详细结构

```
页面头部 (20字节示例):
+----------+----------+----------+----------+----------+
| 页面类型  | 键数量    | 父页面ID  | 右兄弟ID  | 自由指针  |
| (1字节)  | (2字节)  | (4字节)  | (4字节)  | (2字节)  |
+----------+----------+----------+----------+----------+
| 自由空间  | 保留字段  | 校验和   | 版本信息  | 其他     |
| (2字节)  | (2字节)  | (2字节)  | (1字节)  | ...     |
+----------+----------+----------+----------+----------+
```

### 4.1.3 单元格指针数组

```
单元格指针数组：
+--------+--------+--------+--------+
|offset1 |offset2 |offset3 |offsetN |
|  →     |  →     |  →     |  →     |
+--------+--------+--------+--------+
   |        |        |        |
   v        v        v        v
[Cell1]  [Cell2]  [Cell3]  [CellN] （在页面底部）
```

## 4.2 单元格内部结构（自底向上）

### 4.2.1 叶子节点单元格

```
叶子节点单元格结构：
+----------------------+
|     单元格头部        |
|   - 单元格大小        |  (2字节)
|   - 键大小           |  (2字节)  
+----------------------+
|        键值          |  (可变长度)
|     (Key Data)      |
+----------------------+
|       数据记录        |  (可变长度)
|   (Record Data)     |
|   或数据记录指针      |
+----------------------+
```

### 4.2.2 内部节点单元格

```
内部节点单元格结构：
+----------------------+
|     单元格头部        |
|   - 单元格大小        |  (2字节)
|   - 键大小           |  (2字节)
+----------------------+
|        键值          |  (可变长度)
|     (Key Data)      |
+----------------------+
|     子页面指针        |  (4字节)
|   (Child Page ID)   |
+----------------------+
```

## 4.3 B树节点组织（自底向上构建）

### 4.3.1 从单元格到节点

```
步骤1：构建单元格
Cell1: [Size|KeySize|"Alice"|DataPtr]
Cell2: [Size|KeySize|"Bob"|DataPtr]  
Cell3: [Size|KeySize|"Charlie"|DataPtr]

步骤2：组织到页面
+-------------------+
|   Page Header     |
+-------------------+
|[off1][off2][off3] | ← 指针数组
+-------------------+
|   Free Space      |
+-------------------+
|     Cell3         | ← "Charlie"
|     Cell2         | ← "Bob"  
|     Cell1         | ← "Alice"
+-------------------+

步骤3：形成B树节点
         [根节点]
           |
    +------+------+
    |             |
[叶节点1]     [叶节点2]
包含Alice     包含Charlie
```

### 4.3.2 B树的层次结构

```
B树完整结构示例（阶数=3）：

                    [M|页面ID=1]
                  /            \
            [D,G|页面ID=2]    [P,S|页面ID=3]
           /      |     \      /    |    \
    [A,B,C|ID=4][E,F|ID=5][H,I,J|ID=6][N,O|ID=7][Q,R|ID=8][T,U,V|ID=9]

每个节点对应一个页面，页面ID用于磁盘定位
单元格内的键按序存储，指针指向子页面
```

## 4.4 B树运行原理演示

### 4.4.1 查询操作示例

**场景**：在B树中查找键值"F"

```
第1步：从根节点开始 (PageID=1)
+-------------------+
| Header: 根节点     |
+-------------------+  
|[ptr1][ptr2]      | 指针数组
+-------------------+
|   Free Space     |
+-------------------+
|[Size|2|"M"|ID=2] | Cell2: M → PageID=2
|[Size|1|""|ID=3] | Cell1: 最小值 → PageID=3  
+-------------------+
比较：F < M，走左子树 → PageID=2

第2步：访问PageID=2节点
+-------------------+
| Header: 内部节点   |
+-------------------+
|[ptr1][ptr2][ptr3]| 指针数组  
+-------------------+
|   Free Space     |
+-------------------+
|[Size|2|"G"|ID=6] | Cell3: G → PageID=6
|[Size|2|"D"|ID=5] | Cell2: D → PageID=5
|[Size|1|""|ID=4] | Cell1: 最小值 → PageID=4
+-------------------+
比较：D < F < G，走中间子树 → PageID=5

第3步：访问叶子节点PageID=5
+-------------------+
| Header: 叶子节点   |
+-------------------+
|[ptr1][ptr2]      | 指针数组
+-------------------+
|   Free Space     |
+-------------------+
|[Size|8|"F"|Data] | Cell2: 找到F！
|[Size|8|"E"|Data] | Cell1: E的数据
+-------------------+
找到目标，返回F对应的数据
```

### 4.4.2 插入操作示例

**场景**：向B树插入键值"F2"

```
第1步：定位插入位置
按查找流程找到应插入的叶子节点（PageID=5）

第2步：检查空间
+-------------------+
| Header: 剩余空间   | ← 检查Free Space
+-------------------+
|[ptr1][ptr2]      | 
+-------------------+
| 剩余空间：100字节  | ← 足够容纳新Cell
+-------------------+
|[Size|8|"F"|Data] |
|[Size|8|"E"|Data] |
+-------------------+

第3步：插入新单元格
+-------------------+
| Header: 更新键数量 |
+-------------------+
|[ptr1][ptr2][ptr3]| ← 新增指针
+-------------------+
| 剩余空间：80字节   | ← 空间减少
+-------------------+
|[Size|8|"F2"|Data]| ← 新插入
|[Size|8|"F"|Data] |
|[Size|8|"E"|Data] |
+-------------------+

第4步：维护有序性
单元格在页面内按键值排序：E < F < F2
指针数组按相同顺序排列
```

### 4.4.3 删除操作示例

**场景**：删除键值"F"

```
第1步：定位目标
找到包含"F"的叶子节点（PageID=5）

第2步：删除单元格
+-------------------+      +-------------------+
| Header: 键数=3    |  →   | Header: 键数=2    |
+-------------------+      +-------------------+
|[ptr1][ptr2][ptr3]|  →   |[ptr1][ptr2]      |
+-------------------+      +-------------------+
| 剩余空间：80字节  |  →   | 剩余空间：100字节 |
+-------------------+      +-------------------+
|[Size|8|"F2"|Data]|  →   |[Size|8|"F2"|Data]|
|[Size|8|"F"|Data] |  →   |        清除        |
|[Size|8|"E"|Data] |  →   |[Size|8|"E"|Data] |
+-------------------+      +-------------------+

第3步：空间整理（可选）
将删除留下的空隙合并到Free Space中
更新单元格指针数组

第4步：检查节点最小填充度
如果删除后节点键数过少，需要：
- 从兄弟节点借键
- 或与兄弟节点合并
```

### 4.4.4 页面分裂示例

**场景**：向已满页面插入导致分裂

```
分裂前（页面已满，无法插入"G"）：
+-------------------------+
| Header: 键数=5 (最大容量) |
+-------------------------+
|[ptr1][ptr2][ptr3][ptr4][ptr5]|
+-------------------------+
| 剩余空间：0字节           |
+-------------------------+
|[Size|8|"J"|Data]       |
|[Size|8|"I"|Data]       |
|[Size|8|"H"|Data]       |
|[Size|8|"F"|Data]       |
|[Size|8|"E"|Data]       |
+-------------------------+

分裂过程：
1. 创建新页面（PageID=10）
2. 将一半键移动到新页面
3. 更新父节点指针

分裂后：
原页面（PageID=5）：           新页面（PageID=10）：
+-------------------+        +-------------------+
| Header: 键数=2     |        | Header: 键数=3     |
+-------------------+        +-------------------+
|[ptr1][ptr2]      |        |[ptr1][ptr2][ptr3] |
+-------------------+        +-------------------+
| 剩余空间：充足     |        | 剩余空间：充足     |
+-------------------+        +-------------------+
|[Size|8|"G"|Data] |        |[Size|8|"J"|Data] |
|[Size|8|"F"|Data] |        |[Size|8|"I"|Data] |
|[Size|8|"E"|Data] |        |[Size|8|"H"|Data] |
+-------------------+        +-------------------+

父节点更新：
+-------------------------+
| 新增分裂键"H"和指向新页面的指针 |
+-------------------------+
```

## 4.5 B树设计优势总结

1. **页面对齐**：每个节点占据完整页面，最大化I/O效率
2. **紧凑布局**：头部+指针+单元格的结构充分利用空间
3. **灵活寻址**：页面ID+单元格偏移的两级指针系统
4. **顺序访问**：单元格按键值排序，支持范围查询
5. **均衡分裂**：自动维护树的平衡，保证性能稳定

通过这种精心设计的布局结构，B树能够高效地支持大规模数据的存储和检索，成为现代数据库系统的核心索引技术。

